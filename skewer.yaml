title: Skupper Hello World Docker
subtitle: A minimal HTTP application deployed across Kubernetes and Docker sites using Skupper
github_actions_url: https://github.com/ssorj/skupper-example-hello-world-docker/actions/workflows/main.yaml
overview: |
  This example is a very simple multi-service HTTP application
  deployed across a Kubernetes cluster and a bare-metal host or VM
  running Docker containers.

  It contains two services:

  * A backend service that exposes an `/api/hello` endpoint.  It
    returns greetings of the form `Hi, <your-name>.  I am <my-name>
    (<pod-name>)`.

  * A frontend service that sends greetings to the backend and
    fetches new greetings in response.

  With Skupper, you can run the backend as a container on your local
  machine and the frontend in Kubernetes and maintain connectivity
  between the two services without exposing the backend to the public
  internet.

  <!-- <img src="images/entities.svg" width="640"/> -->
prerequisites: |
  * A working installation of Docker ([installation
    guide][install-docker]) or Podman ([installation
    guide][install-podman])

  * The `kubectl` command-line tool, version 1.15 or later
    ([installation guide][install-kubectl])

  * Access to a Kubernetes cluster, from [any provider you
    choose][kube-providers]

  [install-docker]: https://docs.docker.com/engine/install/
  [install-podman]: https://podman.io/getting-started/installation
  [install-kubectl]: https://kubernetes.io/docs/tasks/tools/install-kubectl/
  [kube-providers]: https://skupper.io/start/index.html#prerequisites
sites:
  hello-world:
    kubeconfig: ~/.kube/config-hello-world
    namespace: hello-world
steps:
  - standard: install_the_skupper_command_line_tool
  - title: Access your Kubernetes cluster
    preamble: |
      The procedure for accessing a Kubernetes cluster varies by
      provider. Find the instructions for your chosen provider and use
      them to authenticate and configure access for each console
      session.  See the following links for more information:

      * [Minikube](https://skupper.io/start/minikube.html)
      * [Amazon Elastic Kubernetes Service (EKS)](https://skupper.io/start/eks.html)
      * [Azure Kubernetes Service (AKS)](https://skupper.io/start/aks.html)
      * [Google Kubernetes Engine (GKE)](https://skupper.io/start/gke.html)
      * [IBM Kubernetes Service](https://skupper.io/start/ibmks.html)
      * [OpenShift](https://skupper.io/start/openshift.html)
      * [More providers](https://kubernetes.io/partners/#kcsp)
  - title: Set up your Kubernetes namespace
    preamble: |
      Use `kubectl create namespace` to create the namespace you wish
      to use (or use an existing namespace).  Use `kubectl config
      set-context` to set the current namespace for your session.
    commands:
      hello-world:
        - run: kubectl create namespace hello-world
          output: namespace/hello-world created
        - run: kubectl config set-context --current --namespace hello-world
          output: Context "minikube" modified.
  - title: Install Skupper in your Kubernetes namespace
    preamble: |
      The `skupper init` command installs the Skupper router and service
      controller in the current namespace.

      **Note:** If you are using Minikube, [you need to start `minikube
      tunnel`][minikube-tunnel] before you install Skupper.

      [minikube-tunnel]: https://skupper.io/start/minikube.html#running-minikube-tunnel
    commands:
      hello-world:
        - run: skupper init
          output: |
            Waiting for LoadBalancer IP or hostname...
            Skupper is now installed in namespace 'hello-world'.  Use 'skupper status' to get more information.
  - title: Deploy and expose the backend on your local machine
    preamble: |
      Use `docker` to run the backend service on your local machine.

      Use the `skupper gateway expose` command to expose the backend
      on the Skupper network.  Use `kubectl get service/backend` to
      ensure the backend service is available.
    commands:
      hello-world:
        - run: docker run --name backend --detach --rm -p 8080:8080 quay.io/skupper/hello-world-backend
          output: |
            262dde0287af2c76c3088d9ff4f865f02732a762b0afd91e03ec9e3fe6b03f88
        - run: skupper gateway expose backend localhost 8080 --type docker
          output: |
            2022/08/26 07:27:11 CREATE io.skupper.router.tcpConnector fancypants-jross-egress-backend:8080 map[address:backend:8080 host:localhost name:fancypants-jross-egress-backend:8080 port:8080 siteId:f1e916db-8786-4bad-81ce-f1d3531179f0]
        - await: service/backend
        - run: kubectl get service/backend
          output: |
            NAME      TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
            backend   ClusterIP   10.101.76.37   <none>        8080/TCP   10s
  - title: Deploy and expose the frontend on Kubernetes
    preamble: |
      Use `kubectl create deployment` to deploy the frontend service
      in `hello-world`.

      Use `kubectl expose` with `--type LoadBalancer` to open network
      access to the frontend service.
    commands:
      hello-world:
        - run: kubectl create deployment frontend --image quay.io/skupper/hello-world-frontend
          output: deployment.apps/frontend created
        - await: deployment/frontend
        - run: kubectl expose deployment/frontend --port 8080 --type LoadBalancer
          output: service/frontend exposed
        # curl --verbose -H "Content-Type: application/json" -d '{"name": "Hubert"}' http://<service-name>:8080/api/hello
  - standard: test_the_application
  - standard: accessing_the_web_console
  - standard: cleaning_up
    commands:
      hello-world:
        - run: docker stop backend
        - run: skupper gateway delete
        - run: skupper delete
        - run: kubectl delete service/frontend
        - run: kubectl delete deployment/frontend
